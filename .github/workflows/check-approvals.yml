name: Verify Required Reviewers

on:
  pull_request_target:
    types: [opened, edited, synchronize, reopened]
  pull_request_review:
    types: [submitted, dismissed]

jobs:
  identify-reviewers:
    runs-on: ubuntu-latest
    outputs:
      required_users: ${{ steps.parse.outputs.result }}
      has_users: ${{ steps.check_empty.outputs.has_users }}
    steps:
      - name: Parse PR Body
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || "";
            
            // Regex to find the section between "Required Reviewers" and "Mandatory"
            const regex = /#### Required Reviewers([\s\S]*?)#### Mandatory/;
            const match = body.match(regex);
            
            if (!match) return []; // Return empty array if section missing

            const reviewersBlock = match[1];
            
            // Clean and extract usernames
            const users = reviewersBlock.split('\n')
              .map(line => line.trim())
              .filter(line => line.startsWith('-') && line.length > 1)
              .map(line => line.replace('-', '').trim().replace('@', ''))
              .filter(user => !user.includes('<') && user !== "");
            
            console.log("Identified users:", users);
            return users; // This becomes steps.parse.outputs.result

      - name: Check if users exist
        id: check_empty
        run: |
          echo "Checking if list is empty..."
          users='${{ steps.parse.outputs.result }}'
          if [ "$users" == "[]" ]; then
            echo "has_users=false" >> $GITHUB_OUTPUT
          else
            echo "has_users=true" >> $GITHUB_OUTPUT
          fi
          
  verify-approvals:
    needs: identify-reviewers
    if: needs.identify-reviewers.outputs.has_users == 'true'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
      actions: write
    
    steps:
      - name: Check Approval Status
        uses: actions/github-script@v7
        with:
          script: |
            // 1. Retrieve the list from Job 1's output
            const requiredUsers = ${{ needs.identify-reviewers.outputs.required_users }};
            const prNumber = context.payload.pull_request.number;
            
            console.log(`Verifying approvals for: ${requiredUsers.join(', ')}`);

            // 2. Fetch current reviews
            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            // 3. Determine latest state per user
            const latestReviews = {};
            reviews.forEach(review => {
              if (review.user) latestReviews[review.user.login] = review.state;
            });

            // 4. Check for missing approvals
            const missing = requiredUsers.filter(u => latestReviews[u] !== 'APPROVED');

            if (missing.length > 0) {
              core.setFailed(`Blocking Merge. Missing approvals from: ${missing.join(', ')}`);
            } else {
              console.log("Success: All required reviewers have approved.");
            }

      # Self-Healing: If this run was triggered by an approval, fix the previous "stale" failure
      - name: Trigger Stale Check Re-run
        if: github.event_name == 'pull_request_review' && success()
        uses: actions/github-script@v7
        with:
          script: |
            console.log("Review approved. Checking for stale failed runs...");
            const pr = context.payload.pull_request;
            
            // Find the "verify-approvals" job in the 'pull_request_target' event that failed
            const runs = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: pr.head.ref,
              event: 'pull_request_target', 
              status: 'failure',
              per_page: 5
            });

            // Find the run associated with the current commit
            const failedRun = runs.data.workflow_runs.find(run => run.head_sha === pr.head.sha);

            if (failedRun) {
              console.log(`Restarting failed run ID: ${failedRun.id}`);
              await github.rest.actions.reRunWorkflow({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: failedRun.id
              });
            } else {
              console.log("No stale runs found.");
            }